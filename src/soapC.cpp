/* soapC.cpp
   Generated by gSOAP 2.8.3 from enrima.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.3 2011-12-25 11:12:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns2__mathType:
		return soap_in_ns2__mathType(soap, NULL, NULL, "ns2:mathType");
	case SOAP_TYPE_ns2__entityRole:
		return soap_in_ns2__entityRole(soap, NULL, NULL, "ns2:entityRole");
	case SOAP_TYPE_ns2__setType:
		return soap_in_ns2__setType(soap, NULL, NULL, "ns2:setType");
	case SOAP_TYPE_ns2__status:
		return soap_in_ns2__status(soap, NULL, NULL, "ns2:status");
	case SOAP_TYPE_ns2__auditable:
		return soap_in_ns2__auditable(soap, NULL, NULL, "ns2:auditable");
	case SOAP_TYPE_ns2__user:
		return soap_in_ns2__user(soap, NULL, NULL, "ns2:user");
	case SOAP_TYPE_ns2__iteratorContainer:
		return soap_in_ns2__iteratorContainer(soap, NULL, NULL, "ns2:iteratorContainer");
	case SOAP_TYPE_ns2__entity:
		return soap_in_ns2__entity(soap, NULL, NULL, "ns2:entity");
	case SOAP_TYPE_ns2__set:
		return soap_in_ns2__set(soap, NULL, NULL, "ns2:set");
	case SOAP_TYPE_ns2__modelRev:
		return soap_in_ns2__modelRev(soap, NULL, NULL, "ns2:modelRev");
	case SOAP_TYPE_ns2__model:
		return soap_in_ns2__model(soap, NULL, NULL, "ns2:model");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns2__getModelListResponse:
		return soap_in_PointerTo_ns2__getModelListResponse(soap, NULL, NULL, "ns2:getModelListResponse");
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionResponse:
		return soap_in_PointerTo_ns2__saveModelDescriptionResponse(soap, NULL, NULL, "ns2:saveModelDescriptionResponse");
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionRequest:
		return soap_in_PointerTo_ns2__saveModelDescriptionRequest(soap, NULL, NULL, "ns2:saveModelDescriptionRequest");
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionResponse:
		return soap_in_PointerTo_ns2__getModelDescriptionResponse(soap, NULL, NULL, "ns2:getModelDescriptionResponse");
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionRequest:
		return soap_in_PointerTo_ns2__getModelDescriptionRequest(soap, NULL, NULL, "ns2:getModelDescriptionRequest");
	case SOAP_TYPE_PointerTons2__model:
		return soap_in_PointerTons2__model(soap, NULL, NULL, "ns2:model");
	case SOAP_TYPE_PointerTons2__user:
		return soap_in_PointerTons2__user(soap, NULL, NULL, "ns2:user");
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		return soap_in_PointerTons2__iteratorContainer(soap, NULL, NULL, "ns2:iteratorContainer");
	case SOAP_TYPE_PointerTons2__entity:
		return soap_in_PointerTons2__entity(soap, NULL, NULL, "ns2:entity");
	case SOAP_TYPE_PointerTons2__set:
		return soap_in_PointerTons2__set(soap, NULL, NULL, "ns2:set");
	case SOAP_TYPE_PointerTons2__modelRev:
		return soap_in_PointerTons2__modelRev(soap, NULL, NULL, "ns2:modelRev");
	case SOAP_TYPE_PointerTons2__auditable:
		return soap_in_PointerTons2__auditable(soap, NULL, NULL, "ns2:auditable");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:auditable"))
		{	*type = SOAP_TYPE_ns2__auditable;
			return soap_in_ns2__auditable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:user"))
		{	*type = SOAP_TYPE_ns2__user;
			return soap_in_ns2__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:iteratorContainer"))
		{	*type = SOAP_TYPE_ns2__iteratorContainer;
			return soap_in_ns2__iteratorContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:entity"))
		{	*type = SOAP_TYPE_ns2__entity;
			return soap_in_ns2__entity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:set"))
		{	*type = SOAP_TYPE_ns2__set;
			return soap_in_ns2__set(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:modelRev"))
		{	*type = SOAP_TYPE_ns2__modelRev;
			return soap_in_ns2__modelRev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:model"))
		{	*type = SOAP_TYPE_ns2__model;
			return soap_in_ns2__model(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:mathType"))
		{	*type = SOAP_TYPE_ns2__mathType;
			return soap_in_ns2__mathType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:entityRole"))
		{	*type = SOAP_TYPE_ns2__entityRole;
			return soap_in_ns2__entityRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setType"))
		{	*type = SOAP_TYPE_ns2__setType;
			return soap_in_ns2__setType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:status"))
		{	*type = SOAP_TYPE_ns2__status;
			return soap_in_ns2__status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:saveModelDescriptionResponse"))
		{	*type = SOAP_TYPE__ns2__saveModelDescriptionResponse;
			return soap_in__ns2__saveModelDescriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:saveModelDescriptionRequest"))
		{	*type = SOAP_TYPE__ns2__saveModelDescriptionRequest;
			return soap_in__ns2__saveModelDescriptionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getModelDescriptionResponse"))
		{	*type = SOAP_TYPE__ns2__getModelDescriptionResponse;
			return soap_in__ns2__getModelDescriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getModelDescriptionRequest"))
		{	*type = SOAP_TYPE__ns2__getModelDescriptionRequest;
			return soap_in__ns2__getModelDescriptionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getModelListResponse"))
		{	*type = SOAP_TYPE__ns2__getModelListResponse;
			return soap_in__ns2__getModelListResponse(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns2__mathType:
		return soap_out_ns2__mathType(soap, tag, id, (const enum ns2__mathType *)ptr, "ns2:mathType");
	case SOAP_TYPE_ns2__entityRole:
		return soap_out_ns2__entityRole(soap, tag, id, (const enum ns2__entityRole *)ptr, "ns2:entityRole");
	case SOAP_TYPE_ns2__setType:
		return soap_out_ns2__setType(soap, tag, id, (const enum ns2__setType *)ptr, "ns2:setType");
	case SOAP_TYPE_ns2__status:
		return soap_out_ns2__status(soap, tag, id, (const enum ns2__status *)ptr, "ns2:status");
	case SOAP_TYPE__ns2__saveModelDescriptionResponse:
		return ((_ns2__saveModelDescriptionResponse *)ptr)->soap_out(soap, "ns2:saveModelDescriptionResponse", id, NULL);
	case SOAP_TYPE__ns2__saveModelDescriptionRequest:
		return ((_ns2__saveModelDescriptionRequest *)ptr)->soap_out(soap, "ns2:saveModelDescriptionRequest", id, NULL);
	case SOAP_TYPE__ns2__getModelDescriptionResponse:
		return ((_ns2__getModelDescriptionResponse *)ptr)->soap_out(soap, "ns2:getModelDescriptionResponse", id, NULL);
	case SOAP_TYPE__ns2__getModelDescriptionRequest:
		return ((_ns2__getModelDescriptionRequest *)ptr)->soap_out(soap, "ns2:getModelDescriptionRequest", id, NULL);
	case SOAP_TYPE__ns2__getModelListResponse:
		return ((_ns2__getModelListResponse *)ptr)->soap_out(soap, "ns2:getModelListResponse", id, NULL);
	case SOAP_TYPE_ns2__auditable:
		return ((ns2__auditable *)ptr)->soap_out(soap, tag, id, "ns2:auditable");
	case SOAP_TYPE_ns2__user:
		return ((ns2__user *)ptr)->soap_out(soap, tag, id, "ns2:user");
	case SOAP_TYPE_ns2__iteratorContainer:
		return ((ns2__iteratorContainer *)ptr)->soap_out(soap, tag, id, "ns2:iteratorContainer");
	case SOAP_TYPE_ns2__entity:
		return ((ns2__entity *)ptr)->soap_out(soap, tag, id, "ns2:entity");
	case SOAP_TYPE_ns2__set:
		return ((ns2__set *)ptr)->soap_out(soap, tag, id, "ns2:set");
	case SOAP_TYPE_ns2__modelRev:
		return ((ns2__modelRev *)ptr)->soap_out(soap, tag, id, "ns2:modelRev");
	case SOAP_TYPE_ns2__model:
		return ((ns2__model *)ptr)->soap_out(soap, tag, id, "ns2:model");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns2__getModelListResponse:
		return soap_out_PointerTo_ns2__getModelListResponse(soap, tag, id, (_ns2__getModelListResponse *const*)ptr, "ns2:getModelListResponse");
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionResponse:
		return soap_out_PointerTo_ns2__saveModelDescriptionResponse(soap, tag, id, (_ns2__saveModelDescriptionResponse *const*)ptr, "ns2:saveModelDescriptionResponse");
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionRequest:
		return soap_out_PointerTo_ns2__saveModelDescriptionRequest(soap, tag, id, (_ns2__saveModelDescriptionRequest *const*)ptr, "ns2:saveModelDescriptionRequest");
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionResponse:
		return soap_out_PointerTo_ns2__getModelDescriptionResponse(soap, tag, id, (_ns2__getModelDescriptionResponse *const*)ptr, "ns2:getModelDescriptionResponse");
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionRequest:
		return soap_out_PointerTo_ns2__getModelDescriptionRequest(soap, tag, id, (_ns2__getModelDescriptionRequest *const*)ptr, "ns2:getModelDescriptionRequest");
	case SOAP_TYPE_PointerTons2__model:
		return soap_out_PointerTons2__model(soap, tag, id, (ns2__model *const*)ptr, "ns2:model");
	case SOAP_TYPE_PointerTons2__user:
		return soap_out_PointerTons2__user(soap, tag, id, (ns2__user *const*)ptr, "ns2:user");
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		return soap_out_PointerTons2__iteratorContainer(soap, tag, id, (ns2__iteratorContainer *const*)ptr, "ns2:iteratorContainer");
	case SOAP_TYPE_PointerTons2__entity:
		return soap_out_PointerTons2__entity(soap, tag, id, (ns2__entity *const*)ptr, "ns2:entity");
	case SOAP_TYPE_PointerTons2__set:
		return soap_out_PointerTons2__set(soap, tag, id, (ns2__set *const*)ptr, "ns2:set");
	case SOAP_TYPE_PointerTons2__modelRev:
		return soap_out_PointerTons2__modelRev(soap, tag, id, (ns2__modelRev *const*)ptr, "ns2:modelRev");
	case SOAP_TYPE_PointerTons2__auditable:
		return soap_out_PointerTons2__auditable(soap, tag, id, (ns2__auditable *const*)ptr, "ns2:auditable");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns2__saveModelDescriptionResponse:
		((_ns2__saveModelDescriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__saveModelDescriptionRequest:
		((_ns2__saveModelDescriptionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getModelDescriptionResponse:
		((_ns2__getModelDescriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getModelDescriptionRequest:
		((_ns2__getModelDescriptionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getModelListResponse:
		((_ns2__getModelListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__auditable:
		((ns2__auditable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__user:
		((ns2__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__iteratorContainer:
		((ns2__iteratorContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__entity:
		((ns2__entity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__set:
		((ns2__set *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__modelRev:
		((ns2__modelRev *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__model:
		((ns2__model *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__getModelList:
		soap_serialize___ns1__getModelList(soap, (const struct __ns1__getModelList *)ptr);
		break;
	case SOAP_TYPE___ns1__saveModelDescription:
		soap_serialize___ns1__saveModelDescription(soap, (const struct __ns1__saveModelDescription *)ptr);
		break;
	case SOAP_TYPE___ns1__getModelDescription:
		soap_serialize___ns1__getModelDescription(soap, (const struct __ns1__getModelDescription *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getModelListResponse:
		soap_serialize_PointerTo_ns2__getModelListResponse(soap, (_ns2__getModelListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionResponse:
		soap_serialize_PointerTo_ns2__saveModelDescriptionResponse(soap, (_ns2__saveModelDescriptionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__saveModelDescriptionRequest:
		soap_serialize_PointerTo_ns2__saveModelDescriptionRequest(soap, (_ns2__saveModelDescriptionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionResponse:
		soap_serialize_PointerTo_ns2__getModelDescriptionResponse(soap, (_ns2__getModelDescriptionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getModelDescriptionRequest:
		soap_serialize_PointerTo_ns2__getModelDescriptionRequest(soap, (_ns2__getModelDescriptionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__model:
		soap_serialize_PointerTons2__model(soap, (ns2__model *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__user:
		soap_serialize_PointerTons2__user(soap, (ns2__user *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		soap_serialize_PointerTons2__iteratorContainer(soap, (ns2__iteratorContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__entity:
		soap_serialize_PointerTons2__entity(soap, (ns2__entity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__set:
		soap_serialize_PointerTons2__set(soap, (ns2__set *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__modelRev:
		soap_serialize_PointerTons2__modelRev(soap, (ns2__modelRev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__auditable:
		soap_serialize_PointerTons2__auditable(soap, (ns2__auditable *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__model:
		return (void*)soap_instantiate_ns2__model(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__modelRev:
		return (void*)soap_instantiate_ns2__modelRev(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__set:
		return (void*)soap_instantiate_ns2__set(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__entity:
		return (void*)soap_instantiate_ns2__entity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__iteratorContainer:
		return (void*)soap_instantiate_ns2__iteratorContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__user:
		return (void*)soap_instantiate_ns2__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__auditable:
		return (void*)soap_instantiate_ns2__auditable(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getModelListResponse:
		return (void*)soap_instantiate__ns2__getModelListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getModelDescriptionRequest:
		return (void*)soap_instantiate__ns2__getModelDescriptionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getModelDescriptionResponse:
		return (void*)soap_instantiate__ns2__getModelDescriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__saveModelDescriptionRequest:
		return (void*)soap_instantiate__ns2__saveModelDescriptionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__saveModelDescriptionResponse:
		return (void*)soap_instantiate__ns2__saveModelDescriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getModelDescription:
		return (void*)soap_instantiate___ns1__getModelDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__saveModelDescription:
		return (void*)soap_instantiate___ns1__saveModelDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getModelList:
		return (void*)soap_instantiate___ns1__getModelList(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__model:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__model(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entity:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__entity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__set:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__set(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__modelRev:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__modelRev(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__model:
		if (p->size < 0)
			SOAP_DELETE((ns2__model*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__model*)p->ptr);
		break;
	case SOAP_TYPE_ns2__modelRev:
		if (p->size < 0)
			SOAP_DELETE((ns2__modelRev*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__modelRev*)p->ptr);
		break;
	case SOAP_TYPE_ns2__set:
		if (p->size < 0)
			SOAP_DELETE((ns2__set*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__set*)p->ptr);
		break;
	case SOAP_TYPE_ns2__entity:
		if (p->size < 0)
			SOAP_DELETE((ns2__entity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__entity*)p->ptr);
		break;
	case SOAP_TYPE_ns2__iteratorContainer:
		if (p->size < 0)
			SOAP_DELETE((ns2__iteratorContainer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__iteratorContainer*)p->ptr);
		break;
	case SOAP_TYPE_ns2__user:
		if (p->size < 0)
			SOAP_DELETE((ns2__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__user*)p->ptr);
		break;
	case SOAP_TYPE_ns2__auditable:
		if (p->size < 0)
			SOAP_DELETE((ns2__auditable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__auditable*)p->ptr);
		break;
	case SOAP_TYPE__ns2__getModelListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__getModelListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__getModelListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__getModelDescriptionRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns2__getModelDescriptionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__getModelDescriptionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__getModelDescriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__getModelDescriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__getModelDescriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__saveModelDescriptionRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns2__saveModelDescriptionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__saveModelDescriptionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__saveModelDescriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__saveModelDescriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__saveModelDescriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getModelDescription:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getModelDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getModelDescription*)p->ptr);
		break;
	case SOAP_TYPE___ns1__saveModelDescription:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__saveModelDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__saveModelDescription*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getModelList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getModelList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getModelList*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__model:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__model * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__model * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			SOAP_DELETE((std::vector<int >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<int >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entity:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__entity * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__entity * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__set:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__set * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__set * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__modelRev:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__modelRev * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__modelRev * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__model:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__model * >*)p)[len] = *(ns2__model **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__entity * >*)p)[len] = *(ns2__entity **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__set:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__set * >*)p)[len] = *(ns2__set **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__modelRev:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__modelRev * >*)p)[len] = *(ns2__modelRev **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__mathType(struct soap *soap, enum ns2__mathType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__mathType
	*a = SOAP_DEFAULT_ns2__mathType;
#else
	*a = (enum ns2__mathType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__mathType[] =
{	{ (long)ns2__mathType__INTEGER, "INTEGER" },
	{ (long)ns2__mathType__BINARY, "BINARY" },
	{ (long)ns2__mathType__REAL, "REAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__mathType2s(struct soap *soap, enum ns2__mathType n)
{	const char *s = soap_code_str(soap_codes_ns2__mathType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__mathType(struct soap *soap, const char *tag, int id, const enum ns2__mathType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__mathType), type) || soap_send(soap, soap_ns2__mathType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__mathType(struct soap *soap, const char *s, enum ns2__mathType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__mathType, s);
	if (map)
		*a = (enum ns2__mathType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__mathType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__mathType * SOAP_FMAC4 soap_in_ns2__mathType(struct soap *soap, const char *tag, enum ns2__mathType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__mathType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__mathType, sizeof(enum ns2__mathType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__mathType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__mathType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__mathType, 0, sizeof(enum ns2__mathType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__mathType(struct soap *soap, const enum ns2__mathType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__mathType);
	if (soap_out_ns2__mathType(soap, tag?tag:"ns2:mathType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__mathType * SOAP_FMAC4 soap_get_ns2__mathType(struct soap *soap, enum ns2__mathType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__mathType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__entityRole(struct soap *soap, enum ns2__entityRole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__entityRole
	*a = SOAP_DEFAULT_ns2__entityRole;
#else
	*a = (enum ns2__entityRole)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__entityRole[] =
{	{ (long)ns2__entityRole__CONSTANT, "CONSTANT" },
	{ (long)ns2__entityRole__PARAMETER, "PARAMETER" },
	{ (long)ns2__entityRole__DECISION_USCOREVAR, "DECISION_VAR" },
	{ (long)ns2__entityRole__EXTERNAL_USCOREDECISION_USCOREVAR, "EXTERNAL_DECISION_VAR" },
	{ (long)ns2__entityRole__OUTCOME_USCOREVAR, "OUTCOME_VAR" },
	{ (long)ns2__entityRole__AUXILIARY_USCOREVAR, "AUXILIARY_VAR" },
	{ (long)ns2__entityRole__ASSIGNMENT, "ASSIGNMENT" },
	{ (long)ns2__entityRole__CONSTRAINT, "CONSTRAINT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__entityRole2s(struct soap *soap, enum ns2__entityRole n)
{	const char *s = soap_code_str(soap_codes_ns2__entityRole, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__entityRole(struct soap *soap, const char *tag, int id, const enum ns2__entityRole *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__entityRole), type) || soap_send(soap, soap_ns2__entityRole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__entityRole(struct soap *soap, const char *s, enum ns2__entityRole *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__entityRole, s);
	if (map)
		*a = (enum ns2__entityRole)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__entityRole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__entityRole * SOAP_FMAC4 soap_in_ns2__entityRole(struct soap *soap, const char *tag, enum ns2__entityRole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__entityRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__entityRole, sizeof(enum ns2__entityRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__entityRole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__entityRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__entityRole, 0, sizeof(enum ns2__entityRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__entityRole(struct soap *soap, const enum ns2__entityRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__entityRole);
	if (soap_out_ns2__entityRole(soap, tag?tag:"ns2:entityRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__entityRole * SOAP_FMAC4 soap_get_ns2__entityRole(struct soap *soap, enum ns2__entityRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__entityRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__setType(struct soap *soap, enum ns2__setType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__setType
	*a = SOAP_DEFAULT_ns2__setType;
#else
	*a = (enum ns2__setType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__setType[] =
{	{ (long)ns2__setType__COLLECTION, "COLLECTION" },
	{ (long)ns2__setType__SEQUENCE, "SEQUENCE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__setType2s(struct soap *soap, enum ns2__setType n)
{	const char *s = soap_code_str(soap_codes_ns2__setType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setType(struct soap *soap, const char *tag, int id, const enum ns2__setType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setType), type) || soap_send(soap, soap_ns2__setType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__setType(struct soap *soap, const char *s, enum ns2__setType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__setType, s);
	if (map)
		*a = (enum ns2__setType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__setType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__setType * SOAP_FMAC4 soap_in_ns2__setType(struct soap *soap, const char *tag, enum ns2__setType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__setType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setType, sizeof(enum ns2__setType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__setType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__setType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setType, 0, sizeof(enum ns2__setType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__setType(struct soap *soap, const enum ns2__setType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__setType);
	if (soap_out_ns2__setType(soap, tag?tag:"ns2:setType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__setType * SOAP_FMAC4 soap_get_ns2__setType(struct soap *soap, enum ns2__setType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__status(struct soap *soap, enum ns2__status *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__status
	*a = SOAP_DEFAULT_ns2__status;
#else
	*a = (enum ns2__status)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__status[] =
{	{ (long)ns2__status__EDIT, "EDIT" },
	{ (long)ns2__status__TEST, "TEST" },
	{ (long)ns2__status__COMMIT, "COMMIT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__status2s(struct soap *soap, enum ns2__status n)
{	const char *s = soap_code_str(soap_codes_ns2__status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__status(struct soap *soap, const char *tag, int id, const enum ns2__status *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__status), type) || soap_send(soap, soap_ns2__status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__status(struct soap *soap, const char *s, enum ns2__status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__status, s);
	if (map)
		*a = (enum ns2__status)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__status * SOAP_FMAC4 soap_in_ns2__status(struct soap *soap, const char *tag, enum ns2__status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__status, sizeof(enum ns2__status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__status, 0, sizeof(enum ns2__status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__status(struct soap *soap, const enum ns2__status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__status);
	if (soap_out_ns2__status(soap, tag?tag:"ns2:status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__status * SOAP_FMAC4 soap_get_ns2__status(struct soap *soap, enum ns2__status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__saveModelDescriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__saveModelDescriptionResponse::model = NULL;
	/* transient soap skipped */
}

void _ns2__saveModelDescriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__model(soap, &this->_ns2__saveModelDescriptionResponse::model);
	/* transient soap skipped */
}

int _ns2__saveModelDescriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__saveModelDescriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__saveModelDescriptionResponse(struct soap *soap, const char *tag, int id, const _ns2__saveModelDescriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__saveModelDescriptionResponse), type))
		return soap->error;
	if (a->_ns2__saveModelDescriptionResponse::model)
	{	if (soap_out_PointerTons2__model(soap, "model", -1, &a->_ns2__saveModelDescriptionResponse::model, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "model"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__saveModelDescriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__saveModelDescriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionResponse * SOAP_FMAC4 soap_in__ns2__saveModelDescriptionResponse(struct soap *soap, const char *tag, _ns2__saveModelDescriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__saveModelDescriptionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__saveModelDescriptionResponse, sizeof(_ns2__saveModelDescriptionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__saveModelDescriptionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__saveModelDescriptionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_model1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__model(soap, "model", &(a->_ns2__saveModelDescriptionResponse::model), "ns2:model"))
				{	soap_flag_model1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__saveModelDescriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__saveModelDescriptionResponse, 0, sizeof(_ns2__saveModelDescriptionResponse), 0, soap_copy__ns2__saveModelDescriptionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_model1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns2__saveModelDescriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__saveModelDescriptionResponse);
	if (this->soap_out(soap, tag?tag:"ns2:saveModelDescriptionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__saveModelDescriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__saveModelDescriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionResponse * SOAP_FMAC4 soap_get__ns2__saveModelDescriptionResponse(struct soap *soap, _ns2__saveModelDescriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__saveModelDescriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__saveModelDescriptionResponse * SOAP_FMAC2 soap_instantiate__ns2__saveModelDescriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__saveModelDescriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__saveModelDescriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__saveModelDescriptionResponse);
		if (size)
			*size = sizeof(_ns2__saveModelDescriptionResponse);
		((_ns2__saveModelDescriptionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__saveModelDescriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__saveModelDescriptionResponse);
		for (int i = 0; i < n; i++)
			((_ns2__saveModelDescriptionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__saveModelDescriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__saveModelDescriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__saveModelDescriptionResponse %p -> %p\n", q, p));
	*(_ns2__saveModelDescriptionResponse*)p = *(_ns2__saveModelDescriptionResponse*)q;
}

void _ns2__saveModelDescriptionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__saveModelDescriptionRequest::model = NULL;
	/* transient soap skipped */
}

void _ns2__saveModelDescriptionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__model(soap, &this->_ns2__saveModelDescriptionRequest::model);
	/* transient soap skipped */
}

int _ns2__saveModelDescriptionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__saveModelDescriptionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__saveModelDescriptionRequest(struct soap *soap, const char *tag, int id, const _ns2__saveModelDescriptionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__saveModelDescriptionRequest), type))
		return soap->error;
	if (a->_ns2__saveModelDescriptionRequest::model)
	{	if (soap_out_PointerTons2__model(soap, "model", -1, &a->_ns2__saveModelDescriptionRequest::model, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "model"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__saveModelDescriptionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__saveModelDescriptionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionRequest * SOAP_FMAC4 soap_in__ns2__saveModelDescriptionRequest(struct soap *soap, const char *tag, _ns2__saveModelDescriptionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__saveModelDescriptionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__saveModelDescriptionRequest, sizeof(_ns2__saveModelDescriptionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__saveModelDescriptionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__saveModelDescriptionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_model1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__model(soap, "model", &(a->_ns2__saveModelDescriptionRequest::model), "ns2:model"))
				{	soap_flag_model1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__saveModelDescriptionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__saveModelDescriptionRequest, 0, sizeof(_ns2__saveModelDescriptionRequest), 0, soap_copy__ns2__saveModelDescriptionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_model1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns2__saveModelDescriptionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__saveModelDescriptionRequest);
	if (this->soap_out(soap, tag?tag:"ns2:saveModelDescriptionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__saveModelDescriptionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__saveModelDescriptionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionRequest * SOAP_FMAC4 soap_get__ns2__saveModelDescriptionRequest(struct soap *soap, _ns2__saveModelDescriptionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__saveModelDescriptionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__saveModelDescriptionRequest * SOAP_FMAC2 soap_instantiate__ns2__saveModelDescriptionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__saveModelDescriptionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__saveModelDescriptionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__saveModelDescriptionRequest);
		if (size)
			*size = sizeof(_ns2__saveModelDescriptionRequest);
		((_ns2__saveModelDescriptionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__saveModelDescriptionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__saveModelDescriptionRequest);
		for (int i = 0; i < n; i++)
			((_ns2__saveModelDescriptionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__saveModelDescriptionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__saveModelDescriptionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__saveModelDescriptionRequest %p -> %p\n", q, p));
	*(_ns2__saveModelDescriptionRequest*)p = *(_ns2__saveModelDescriptionRequest*)q;
}

void _ns2__getModelDescriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getModelDescriptionResponse::model = NULL;
	/* transient soap skipped */
}

void _ns2__getModelDescriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__model(soap, &this->_ns2__getModelDescriptionResponse::model);
	/* transient soap skipped */
}

int _ns2__getModelDescriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getModelDescriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getModelDescriptionResponse(struct soap *soap, const char *tag, int id, const _ns2__getModelDescriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getModelDescriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__model(soap, "model", -1, &(a->_ns2__getModelDescriptionResponse::model), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getModelDescriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getModelDescriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionResponse * SOAP_FMAC4 soap_in__ns2__getModelDescriptionResponse(struct soap *soap, const char *tag, _ns2__getModelDescriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getModelDescriptionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getModelDescriptionResponse, sizeof(_ns2__getModelDescriptionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getModelDescriptionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getModelDescriptionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_model1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__model(soap, "model", &(a->_ns2__getModelDescriptionResponse::model), "ns2:model"))
				{	soap_flag_model1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getModelDescriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getModelDescriptionResponse, 0, sizeof(_ns2__getModelDescriptionResponse), 0, soap_copy__ns2__getModelDescriptionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__getModelDescriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getModelDescriptionResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getModelDescriptionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getModelDescriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getModelDescriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionResponse * SOAP_FMAC4 soap_get__ns2__getModelDescriptionResponse(struct soap *soap, _ns2__getModelDescriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getModelDescriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__getModelDescriptionResponse * SOAP_FMAC2 soap_instantiate__ns2__getModelDescriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getModelDescriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getModelDescriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelDescriptionResponse);
		if (size)
			*size = sizeof(_ns2__getModelDescriptionResponse);
		((_ns2__getModelDescriptionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelDescriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getModelDescriptionResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getModelDescriptionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getModelDescriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getModelDescriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getModelDescriptionResponse %p -> %p\n", q, p));
	*(_ns2__getModelDescriptionResponse*)p = *(_ns2__getModelDescriptionResponse*)q;
}

void _ns2__getModelDescriptionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns2__getModelDescriptionRequest::idModel);
	/* transient soap skipped */
}

void _ns2__getModelDescriptionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns2__getModelDescriptionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getModelDescriptionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getModelDescriptionRequest(struct soap *soap, const char *tag, int id, const _ns2__getModelDescriptionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getModelDescriptionRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModel", -1, &(a->_ns2__getModelDescriptionRequest::idModel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getModelDescriptionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getModelDescriptionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionRequest * SOAP_FMAC4 soap_in__ns2__getModelDescriptionRequest(struct soap *soap, const char *tag, _ns2__getModelDescriptionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getModelDescriptionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getModelDescriptionRequest, sizeof(_ns2__getModelDescriptionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getModelDescriptionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getModelDescriptionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModel", &(a->_ns2__getModelDescriptionRequest::idModel), "xsd:int"))
				{	soap_flag_idModel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getModelDescriptionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getModelDescriptionRequest, 0, sizeof(_ns2__getModelDescriptionRequest), 0, soap_copy__ns2__getModelDescriptionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns2__getModelDescriptionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getModelDescriptionRequest);
	if (this->soap_out(soap, tag?tag:"ns2:getModelDescriptionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getModelDescriptionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getModelDescriptionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionRequest * SOAP_FMAC4 soap_get__ns2__getModelDescriptionRequest(struct soap *soap, _ns2__getModelDescriptionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getModelDescriptionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__getModelDescriptionRequest * SOAP_FMAC2 soap_instantiate__ns2__getModelDescriptionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getModelDescriptionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getModelDescriptionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelDescriptionRequest);
		if (size)
			*size = sizeof(_ns2__getModelDescriptionRequest);
		((_ns2__getModelDescriptionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelDescriptionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getModelDescriptionRequest);
		for (int i = 0; i < n; i++)
			((_ns2__getModelDescriptionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getModelDescriptionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getModelDescriptionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getModelDescriptionRequest %p -> %p\n", q, p));
	*(_ns2__getModelDescriptionRequest*)p = *(_ns2__getModelDescriptionRequest*)q;
}

void _ns2__getModelListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__model(soap, &this->_ns2__getModelListResponse::model);
	/* transient soap skipped */
}

void _ns2__getModelListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__model(soap, &this->_ns2__getModelListResponse::model);
	/* transient soap skipped */
}

int _ns2__getModelListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getModelListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getModelListResponse(struct soap *soap, const char *tag, int id, const _ns2__getModelListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getModelListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__model(soap, "model", -1, &(a->_ns2__getModelListResponse::model), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getModelListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getModelListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getModelListResponse * SOAP_FMAC4 soap_in__ns2__getModelListResponse(struct soap *soap, const char *tag, _ns2__getModelListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getModelListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getModelListResponse, sizeof(_ns2__getModelListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getModelListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getModelListResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__model(soap, "model", &(a->_ns2__getModelListResponse::model), "ns2:model"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getModelListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getModelListResponse, 0, sizeof(_ns2__getModelListResponse), 0, soap_copy__ns2__getModelListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns2__getModelListResponse::model.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns2__getModelListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getModelListResponse);
	if (this->soap_out(soap, tag?tag:"ns2:getModelListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getModelListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getModelListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getModelListResponse * SOAP_FMAC4 soap_get__ns2__getModelListResponse(struct soap *soap, _ns2__getModelListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getModelListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__getModelListResponse * SOAP_FMAC2 soap_instantiate__ns2__getModelListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getModelListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getModelListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelListResponse);
		if (size)
			*size = sizeof(_ns2__getModelListResponse);
		((_ns2__getModelListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__getModelListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getModelListResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getModelListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getModelListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getModelListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getModelListResponse %p -> %p\n", q, p));
	*(_ns2__getModelListResponse*)p = *(_ns2__getModelListResponse*)q;
}

void ns2__auditable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->ns2__auditable::creationDate);
	this->ns2__auditable::createdBy = NULL;
	soap_default_xsd__date(soap, &this->ns2__auditable::modificationDate);
	this->ns2__auditable::modifieddBy = NULL;
	/* transient soap skipped */
}

void ns2__auditable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->ns2__auditable::creationDate);
	soap_serialize_PointerTons2__user(soap, &this->ns2__auditable::createdBy);
	soap_serialize_xsd__date(soap, &this->ns2__auditable::modificationDate);
	soap_serialize_PointerTons2__user(soap, &this->ns2__auditable::modifieddBy);
	/* transient soap skipped */
}

int ns2__auditable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__auditable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__auditable(struct soap *soap, const char *tag, int id, const ns2__auditable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__auditable), type))
		return soap->error;
	if (soap_out_xsd__date(soap, "creationDate", -1, &(a->ns2__auditable::creationDate), ""))
		return soap->error;
	if (a->ns2__auditable::createdBy)
	{	if (soap_out_PointerTons2__user(soap, "createdBy", -1, &a->ns2__auditable::createdBy, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "createdBy"))
		return soap->error;
	if (soap_out_xsd__date(soap, "modificationDate", -1, &(a->ns2__auditable::modificationDate), ""))
		return soap->error;
	if (a->ns2__auditable::modifieddBy)
	{	if (soap_out_PointerTons2__user(soap, "modifieddBy", -1, &a->ns2__auditable::modifieddBy, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modifieddBy"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__auditable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__auditable(soap, tag, this, type);
}

SOAP_FMAC3 ns2__auditable * SOAP_FMAC4 soap_in_ns2__auditable(struct soap *soap, const char *tag, ns2__auditable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__auditable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__auditable, sizeof(ns2__auditable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__auditable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__auditable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_creationDate1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_modificationDate1 = 1;
	size_t soap_flag_modifieddBy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_creationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "creationDate", &(a->ns2__auditable::creationDate), "xsd:date"))
				{	soap_flag_creationDate1--;
					continue;
				}
			if (soap_flag_createdBy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__user(soap, "createdBy", &(a->ns2__auditable::createdBy), "ns2:user"))
				{	soap_flag_createdBy1--;
					continue;
				}
			if (soap_flag_modificationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "modificationDate", &(a->ns2__auditable::modificationDate), "xsd:date"))
				{	soap_flag_modificationDate1--;
					continue;
				}
			if (soap_flag_modifieddBy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__user(soap, "modifieddBy", &(a->ns2__auditable::modifieddBy), "ns2:user"))
				{	soap_flag_modifieddBy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__auditable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__auditable, 0, sizeof(ns2__auditable), 0, soap_copy_ns2__auditable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_creationDate1 > 0 || soap_flag_createdBy1 > 0 || soap_flag_modificationDate1 > 0 || soap_flag_modifieddBy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__auditable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__auditable);
	if (this->soap_out(soap, tag?tag:"ns2:auditable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__auditable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__auditable(soap, this, tag, type);
}

SOAP_FMAC3 ns2__auditable * SOAP_FMAC4 soap_get_ns2__auditable(struct soap *soap, ns2__auditable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__auditable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__auditable * SOAP_FMAC2 soap_instantiate_ns2__auditable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__auditable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__auditable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__auditable);
		if (size)
			*size = sizeof(ns2__auditable);
		((ns2__auditable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__auditable[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__auditable);
		for (int i = 0; i < n; i++)
			((ns2__auditable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__auditable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__auditable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__auditable %p -> %p\n", q, p));
	*(ns2__auditable*)p = *(ns2__auditable*)q;
}

void ns2__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__user::id);
	soap_default_std__string(soap, &this->ns2__user::login);
	/* transient soap skipped */
}

void ns2__user::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns2__user::login);
	/* transient soap skipped */
}

int ns2__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__user(struct soap *soap, const char *tag, int id, const ns2__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__user), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns2__user::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "login", -1, &(a->ns2__user::login), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__user(soap, tag, this, type);
}

SOAP_FMAC3 ns2__user * SOAP_FMAC4 soap_in_ns2__user(struct soap *soap, const char *tag, ns2__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__user, sizeof(ns2__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_login1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns2__user::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "login", &(a->ns2__user::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__user, 0, sizeof(ns2__user), 0, soap_copy_ns2__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_login1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__user);
	if (this->soap_out(soap, tag?tag:"ns2:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__user(soap, this, tag, type);
}

SOAP_FMAC3 ns2__user * SOAP_FMAC4 soap_get_ns2__user(struct soap *soap, ns2__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__user * SOAP_FMAC2 soap_instantiate_ns2__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__user, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__user);
		if (size)
			*size = sizeof(ns2__user);
		((ns2__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__user[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__user);
		for (int i = 0; i < n; i++)
			((ns2__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__user %p -> %p\n", q, p));
	*(ns2__user*)p = *(ns2__user*)q;
}

void ns2__iteratorContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns2__iteratorContainer::idSet);
	/* transient soap skipped */
}

void ns2__iteratorContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns2__iteratorContainer::idSet);
	/* transient soap skipped */
}

int ns2__iteratorContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__iteratorContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__iteratorContainer(struct soap *soap, const char *tag, int id, const ns2__iteratorContainer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__iteratorContainer), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "idSet", -1, &(a->ns2__iteratorContainer::idSet), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__iteratorContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__iteratorContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__iteratorContainer * SOAP_FMAC4 soap_in_ns2__iteratorContainer(struct soap *soap, const char *tag, ns2__iteratorContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__iteratorContainer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__iteratorContainer, sizeof(ns2__iteratorContainer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__iteratorContainer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__iteratorContainer *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "idSet", &(a->ns2__iteratorContainer::idSet), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__iteratorContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__iteratorContainer, 0, sizeof(ns2__iteratorContainer), 0, soap_copy_ns2__iteratorContainer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__iteratorContainer::idSet.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__iteratorContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__iteratorContainer);
	if (this->soap_out(soap, tag?tag:"ns2:iteratorContainer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__iteratorContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__iteratorContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__iteratorContainer * SOAP_FMAC4 soap_get_ns2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__iteratorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__iteratorContainer * SOAP_FMAC2 soap_instantiate_ns2__iteratorContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__iteratorContainer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__iteratorContainer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__iteratorContainer);
		if (size)
			*size = sizeof(ns2__iteratorContainer);
		((ns2__iteratorContainer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__iteratorContainer[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__iteratorContainer);
		for (int i = 0; i < n; i++)
			((ns2__iteratorContainer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__iteratorContainer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__iteratorContainer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__iteratorContainer %p -> %p\n", q, p));
	*(ns2__iteratorContainer*)p = *(ns2__iteratorContainer*)q;
}

void ns2__entity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__entity::id);
	soap_default_std__string(soap, &this->ns2__entity::label);
	soap_default_std__string(soap, &this->ns2__entity::description);
	soap_default_std__string(soap, &this->ns2__entity::note);
	soap_default_double(soap, &this->ns2__entity::constantValue);
	this->ns2__entity::iteratorContainer = NULL;
	soap_default_ns2__entityRole(soap, &this->ns2__entity::role);
	soap_default_ns2__mathType(soap, &this->ns2__entity::mathType);
	soap_default_std__string(soap, &this->ns2__entity::unit);
	soap_default_std__string(soap, &this->ns2__entity::formula);
	/* transient soap skipped */
}

void ns2__entity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns2__entity::label);
	soap_serialize_std__string(soap, &this->ns2__entity::description);
	soap_serialize_std__string(soap, &this->ns2__entity::note);
	soap_serialize_PointerTons2__iteratorContainer(soap, &this->ns2__entity::iteratorContainer);
	soap_serialize_std__string(soap, &this->ns2__entity::unit);
	soap_serialize_std__string(soap, &this->ns2__entity::formula);
	/* transient soap skipped */
}

int ns2__entity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__entity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__entity(struct soap *soap, const char *tag, int id, const ns2__entity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__entity), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns2__entity::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "label", -1, &(a->ns2__entity::label), ""))
		return soap->error;
	if (soap_out_std__string(soap, "description", -1, &(a->ns2__entity::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "note", -1, &(a->ns2__entity::note), ""))
		return soap->error;
	if (soap_out_double(soap, "constantValue", -1, &(a->ns2__entity::constantValue), ""))
		return soap->error;
	if (a->ns2__entity::iteratorContainer)
	{	if (soap_out_PointerTons2__iteratorContainer(soap, "iteratorContainer", -1, &a->ns2__entity::iteratorContainer, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "iteratorContainer"))
		return soap->error;
	if (soap_out_ns2__entityRole(soap, "role", -1, &(a->ns2__entity::role), ""))
		return soap->error;
	if (soap_out_ns2__mathType(soap, "mathType", -1, &(a->ns2__entity::mathType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "unit", -1, &(a->ns2__entity::unit), ""))
		return soap->error;
	if (soap_out_std__string(soap, "formula", -1, &(a->ns2__entity::formula), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__entity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__entity(soap, tag, this, type);
}

SOAP_FMAC3 ns2__entity * SOAP_FMAC4 soap_in_ns2__entity(struct soap *soap, const char *tag, ns2__entity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__entity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__entity, sizeof(ns2__entity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__entity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__entity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_label1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_constantValue1 = 1;
	size_t soap_flag_iteratorContainer1 = 1;
	size_t soap_flag_role1 = 1;
	size_t soap_flag_mathType1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_formula1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns2__entity::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "label", &(a->ns2__entity::label), "xsd:string"))
				{	soap_flag_label1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "description", &(a->ns2__entity::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "note", &(a->ns2__entity::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_constantValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "constantValue", &(a->ns2__entity::constantValue), "xsd:double"))
				{	soap_flag_constantValue1--;
					continue;
				}
			if (soap_flag_iteratorContainer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__iteratorContainer(soap, "iteratorContainer", &(a->ns2__entity::iteratorContainer), "ns2:iteratorContainer"))
				{	soap_flag_iteratorContainer1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__entityRole(soap, "role", &(a->ns2__entity::role), "ns2:entityRole"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_mathType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__mathType(soap, "mathType", &(a->ns2__entity::mathType), "ns2:mathType"))
				{	soap_flag_mathType1--;
					continue;
				}
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "unit", &(a->ns2__entity::unit), "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap_flag_formula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "formula", &(a->ns2__entity::formula), "xsd:string"))
				{	soap_flag_formula1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__entity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__entity, 0, sizeof(ns2__entity), 0, soap_copy_ns2__entity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_label1 > 0 || soap_flag_description1 > 0 || soap_flag_note1 > 0 || soap_flag_constantValue1 > 0 || soap_flag_iteratorContainer1 > 0 || soap_flag_role1 > 0 || soap_flag_mathType1 > 0 || soap_flag_unit1 > 0 || soap_flag_formula1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__entity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__entity);
	if (this->soap_out(soap, tag?tag:"ns2:entity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__entity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__entity(soap, this, tag, type);
}

SOAP_FMAC3 ns2__entity * SOAP_FMAC4 soap_get_ns2__entity(struct soap *soap, ns2__entity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__entity * SOAP_FMAC2 soap_instantiate_ns2__entity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__entity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__entity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__entity);
		if (size)
			*size = sizeof(ns2__entity);
		((ns2__entity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__entity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__entity);
		for (int i = 0; i < n; i++)
			((ns2__entity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__entity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__entity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__entity %p -> %p\n", q, p));
	*(ns2__entity*)p = *(ns2__entity*)q;
}

void ns2__set::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__set::id);
	soap_default_int(soap, &this->ns2__set::parentSetId);
	soap_default_std__string(soap, &this->ns2__set::label);
	soap_default_std__string(soap, &this->ns2__set::description);
	soap_default_std__string(soap, &this->ns2__set::note);
	soap_default_ns2__setType(soap, &this->ns2__set::type);
	this->ns2__set::iteratorContainer = NULL;
	/* transient soap skipped */
}

void ns2__set::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns2__set::label);
	soap_serialize_std__string(soap, &this->ns2__set::description);
	soap_serialize_std__string(soap, &this->ns2__set::note);
	soap_serialize_PointerTons2__iteratorContainer(soap, &this->ns2__set::iteratorContainer);
	/* transient soap skipped */
}

int ns2__set::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__set(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__set(struct soap *soap, const char *tag, int id, const ns2__set *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__set), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns2__set::id), ""))
		return soap->error;
	if (soap_out_int(soap, "parentSetId", -1, &(a->ns2__set::parentSetId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "label", -1, &(a->ns2__set::label), ""))
		return soap->error;
	if (soap_out_std__string(soap, "description", -1, &(a->ns2__set::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "note", -1, &(a->ns2__set::note), ""))
		return soap->error;
	if (soap_out_ns2__setType(soap, "type", -1, &(a->ns2__set::type), ""))
		return soap->error;
	if (a->ns2__set::iteratorContainer)
	{	if (soap_out_PointerTons2__iteratorContainer(soap, "iteratorContainer", -1, &a->ns2__set::iteratorContainer, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "iteratorContainer"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__set::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__set(soap, tag, this, type);
}

SOAP_FMAC3 ns2__set * SOAP_FMAC4 soap_in_ns2__set(struct soap *soap, const char *tag, ns2__set *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__set *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__set, sizeof(ns2__set), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__set)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__set *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_parentSetId1 = 1;
	size_t soap_flag_label1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_iteratorContainer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns2__set::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_parentSetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "parentSetId", &(a->ns2__set::parentSetId), "xsd:int"))
				{	soap_flag_parentSetId1--;
					continue;
				}
			if (soap_flag_label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "label", &(a->ns2__set::label), "xsd:string"))
				{	soap_flag_label1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "description", &(a->ns2__set::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "note", &(a->ns2__set::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__setType(soap, "type", &(a->ns2__set::type), "ns2:setType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_iteratorContainer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__iteratorContainer(soap, "iteratorContainer", &(a->ns2__set::iteratorContainer), "ns2:iteratorContainer"))
				{	soap_flag_iteratorContainer1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__set *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__set, 0, sizeof(ns2__set), 0, soap_copy_ns2__set);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_parentSetId1 > 0 || soap_flag_label1 > 0 || soap_flag_description1 > 0 || soap_flag_note1 > 0 || soap_flag_type1 > 0 || soap_flag_iteratorContainer1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__set::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__set);
	if (this->soap_out(soap, tag?tag:"ns2:set", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__set::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__set(soap, this, tag, type);
}

SOAP_FMAC3 ns2__set * SOAP_FMAC4 soap_get_ns2__set(struct soap *soap, ns2__set *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__set(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__set * SOAP_FMAC2 soap_instantiate_ns2__set(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__set(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__set, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__set);
		if (size)
			*size = sizeof(ns2__set);
		((ns2__set*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__set[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__set);
		for (int i = 0; i < n; i++)
			((ns2__set*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__set*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__set(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__set %p -> %p\n", q, p));
	*(ns2__set*)p = *(ns2__set*)q;
}

void ns2__modelRev::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__modelRev::id);
	soap_default_int(soap, &this->ns2__modelRev::idModel);
	soap_default_int(soap, &this->ns2__modelRev::revNo);
	soap_default_std__string(soap, &this->ns2__modelRev::description);
	soap_default_std__string(soap, &this->ns2__modelRev::note);
	this->ns2__modelRev::auditable = NULL;
	soap_default_ns2__status(soap, &this->ns2__modelRev::status);
	soap_default_std__vectorTemplateOfPointerTons2__set(soap, &this->ns2__modelRev::set);
	soap_default_std__vectorTemplateOfPointerTons2__entity(soap, &this->ns2__modelRev::entity);
	/* transient soap skipped */
}

void ns2__modelRev::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns2__modelRev::description);
	soap_serialize_std__string(soap, &this->ns2__modelRev::note);
	soap_serialize_PointerTons2__auditable(soap, &this->ns2__modelRev::auditable);
	soap_serialize_std__vectorTemplateOfPointerTons2__set(soap, &this->ns2__modelRev::set);
	soap_serialize_std__vectorTemplateOfPointerTons2__entity(soap, &this->ns2__modelRev::entity);
	/* transient soap skipped */
}

int ns2__modelRev::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__modelRev(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__modelRev(struct soap *soap, const char *tag, int id, const ns2__modelRev *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__modelRev), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns2__modelRev::id), ""))
		return soap->error;
	if (soap_out_int(soap, "idModel", -1, &(a->ns2__modelRev::idModel), ""))
		return soap->error;
	if (soap_out_int(soap, "revNo", -1, &(a->ns2__modelRev::revNo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "description", -1, &(a->ns2__modelRev::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "note", -1, &(a->ns2__modelRev::note), ""))
		return soap->error;
	if (a->ns2__modelRev::auditable)
	{	if (soap_out_PointerTons2__auditable(soap, "auditable", -1, &a->ns2__modelRev::auditable, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "auditable"))
		return soap->error;
	if (soap_out_ns2__status(soap, "status", -1, &(a->ns2__modelRev::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__set(soap, "set", -1, &(a->ns2__modelRev::set), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__entity(soap, "entity", -1, &(a->ns2__modelRev::entity), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__modelRev::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__modelRev(soap, tag, this, type);
}

SOAP_FMAC3 ns2__modelRev * SOAP_FMAC4 soap_in_ns2__modelRev(struct soap *soap, const char *tag, ns2__modelRev *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__modelRev *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__modelRev, sizeof(ns2__modelRev), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__modelRev)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__modelRev *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idModel1 = 1;
	size_t soap_flag_revNo1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_auditable1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns2__modelRev::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_idModel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModel", &(a->ns2__modelRev::idModel), "xsd:int"))
				{	soap_flag_idModel1--;
					continue;
				}
			if (soap_flag_revNo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "revNo", &(a->ns2__modelRev::revNo), "xsd:int"))
				{	soap_flag_revNo1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "description", &(a->ns2__modelRev::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "note", &(a->ns2__modelRev::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_auditable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__auditable(soap, "auditable", &(a->ns2__modelRev::auditable), "ns2:auditable"))
				{	soap_flag_auditable1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__status(soap, "status", &(a->ns2__modelRev::status), "ns2:status"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__set(soap, "set", &(a->ns2__modelRev::set), "ns2:set"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__entity(soap, "entity", &(a->ns2__modelRev::entity), "ns2:entity"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__modelRev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__modelRev, 0, sizeof(ns2__modelRev), 0, soap_copy_ns2__modelRev);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_idModel1 > 0 || soap_flag_revNo1 > 0 || soap_flag_description1 > 0 || soap_flag_note1 > 0 || soap_flag_auditable1 > 0 || soap_flag_status1 > 0 || a->ns2__modelRev::set.size() < 1 || a->ns2__modelRev::entity.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__modelRev::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__modelRev);
	if (this->soap_out(soap, tag?tag:"ns2:modelRev", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__modelRev::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__modelRev(soap, this, tag, type);
}

SOAP_FMAC3 ns2__modelRev * SOAP_FMAC4 soap_get_ns2__modelRev(struct soap *soap, ns2__modelRev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__modelRev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__modelRev * SOAP_FMAC2 soap_instantiate_ns2__modelRev(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__modelRev(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__modelRev, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__modelRev);
		if (size)
			*size = sizeof(ns2__modelRev);
		((ns2__modelRev*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__modelRev[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__modelRev);
		for (int i = 0; i < n; i++)
			((ns2__modelRev*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__modelRev*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__modelRev(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__modelRev %p -> %p\n", q, p));
	*(ns2__modelRev*)p = *(ns2__modelRev*)q;
}

void ns2__model::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__model::id);
	soap_default_std__string(soap, &this->ns2__model::name);
	soap_default_std__string(soap, &this->ns2__model::version);
	soap_default_std__string(soap, &this->ns2__model::description);
	soap_default_std__string(soap, &this->ns2__model::note);
	this->ns2__model::auditable = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__modelRev(soap, &this->ns2__model::revision);
	/* transient soap skipped */
}

void ns2__model::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns2__model::name);
	soap_serialize_std__string(soap, &this->ns2__model::version);
	soap_serialize_std__string(soap, &this->ns2__model::description);
	soap_serialize_std__string(soap, &this->ns2__model::note);
	soap_serialize_PointerTons2__auditable(soap, &this->ns2__model::auditable);
	soap_serialize_std__vectorTemplateOfPointerTons2__modelRev(soap, &this->ns2__model::revision);
	/* transient soap skipped */
}

int ns2__model::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__model(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__model(struct soap *soap, const char *tag, int id, const ns2__model *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__model), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns2__model::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns2__model::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &(a->ns2__model::version), ""))
		return soap->error;
	if (soap_out_std__string(soap, "description", -1, &(a->ns2__model::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "note", -1, &(a->ns2__model::note), ""))
		return soap->error;
	if (a->ns2__model::auditable)
	{	if (soap_out_PointerTons2__auditable(soap, "auditable", -1, &a->ns2__model::auditable, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "auditable"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__modelRev(soap, "revision", -1, &(a->ns2__model::revision), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__model::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__model(soap, tag, this, type);
}

SOAP_FMAC3 ns2__model * SOAP_FMAC4 soap_in_ns2__model(struct soap *soap, const char *tag, ns2__model *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__model *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__model, sizeof(ns2__model), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__model)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__model *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_auditable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns2__model::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns2__model::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(a->ns2__model::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "description", &(a->ns2__model::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "note", &(a->ns2__model::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_auditable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__auditable(soap, "auditable", &(a->ns2__model::auditable), "ns2:auditable"))
				{	soap_flag_auditable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__modelRev(soap, "revision", &(a->ns2__model::revision), "ns2:modelRev"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__model *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__model, 0, sizeof(ns2__model), 0, soap_copy_ns2__model);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_version1 > 0 || soap_flag_description1 > 0 || soap_flag_note1 > 0 || soap_flag_auditable1 > 0 || a->ns2__model::revision.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__model::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__model);
	if (this->soap_out(soap, tag?tag:"ns2:model", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__model::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__model(soap, this, tag, type);
}

SOAP_FMAC3 ns2__model * SOAP_FMAC4 soap_get_ns2__model(struct soap *soap, ns2__model *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__model(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__model * SOAP_FMAC2 soap_instantiate_ns2__model(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__model(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__model, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__model);
		if (size)
			*size = sizeof(ns2__model);
		((ns2__model*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__model[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__model);
		for (int i = 0; i < n; i++)
			((ns2__model*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__model*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__model(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__model %p -> %p\n", q, p));
	*(ns2__model*)p = *(ns2__model*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__date, 0, sizeof(std::string), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getModelList(struct soap *soap, struct __ns1__getModelList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getModelListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getModelList(struct soap *soap, const struct __ns1__getModelList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getModelList(struct soap *soap, const char *tag, int id, const struct __ns1__getModelList *a, const char *type)
{
	soap_outliteral(soap, "ns2:getModelListRequest", &a->ns2__getModelListRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModelList * SOAP_FMAC4 soap_in___ns1__getModelList(struct soap *soap, const char *tag, struct __ns1__getModelList *a, const char *type)
{
	size_t soap_flag_ns2__getModelListRequest = 1;
	short soap_flag;
	a = (struct __ns1__getModelList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getModelList, sizeof(struct __ns1__getModelList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getModelList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getModelListRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:getModelListRequest", &a->ns2__getModelListRequest))
				{	soap_flag_ns2__getModelListRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getModelList(struct soap *soap, const struct __ns1__getModelList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getModelList(soap, tag?tag:"-ns1:getModelList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModelList * SOAP_FMAC4 soap_get___ns1__getModelList(struct soap *soap, struct __ns1__getModelList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getModelList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getModelList * SOAP_FMAC2 soap_instantiate___ns1__getModelList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getModelList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getModelList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getModelList);
		if (size)
			*size = sizeof(struct __ns1__getModelList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getModelList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getModelList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getModelList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getModelList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getModelList %p -> %p\n", q, p));
	*(struct __ns1__getModelList*)p = *(struct __ns1__getModelList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__saveModelDescription(struct soap *soap, struct __ns1__saveModelDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__saveModelDescriptionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__saveModelDescription(struct soap *soap, const struct __ns1__saveModelDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__saveModelDescriptionRequest(soap, &a->ns2__saveModelDescriptionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__saveModelDescription(struct soap *soap, const char *tag, int id, const struct __ns1__saveModelDescription *a, const char *type)
{
	if (soap_out_PointerTo_ns2__saveModelDescriptionRequest(soap, "ns2:saveModelDescriptionRequest", -1, &a->ns2__saveModelDescriptionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__saveModelDescription * SOAP_FMAC4 soap_in___ns1__saveModelDescription(struct soap *soap, const char *tag, struct __ns1__saveModelDescription *a, const char *type)
{
	size_t soap_flag_ns2__saveModelDescriptionRequest = 1;
	short soap_flag;
	a = (struct __ns1__saveModelDescription *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__saveModelDescription, sizeof(struct __ns1__saveModelDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__saveModelDescription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__saveModelDescriptionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__saveModelDescriptionRequest(soap, "ns2:saveModelDescriptionRequest", &a->ns2__saveModelDescriptionRequest, ""))
				{	soap_flag_ns2__saveModelDescriptionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__saveModelDescription(struct soap *soap, const struct __ns1__saveModelDescription *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__saveModelDescription(soap, tag?tag:"-ns1:saveModelDescription", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__saveModelDescription * SOAP_FMAC4 soap_get___ns1__saveModelDescription(struct soap *soap, struct __ns1__saveModelDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__saveModelDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__saveModelDescription * SOAP_FMAC2 soap_instantiate___ns1__saveModelDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__saveModelDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__saveModelDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__saveModelDescription);
		if (size)
			*size = sizeof(struct __ns1__saveModelDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__saveModelDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__saveModelDescription);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__saveModelDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__saveModelDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__saveModelDescription %p -> %p\n", q, p));
	*(struct __ns1__saveModelDescription*)p = *(struct __ns1__saveModelDescription*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getModelDescription(struct soap *soap, struct __ns1__getModelDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getModelDescriptionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getModelDescription(struct soap *soap, const struct __ns1__getModelDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getModelDescriptionRequest(soap, &a->ns2__getModelDescriptionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getModelDescription(struct soap *soap, const char *tag, int id, const struct __ns1__getModelDescription *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getModelDescriptionRequest(soap, "ns2:getModelDescriptionRequest", -1, &a->ns2__getModelDescriptionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModelDescription * SOAP_FMAC4 soap_in___ns1__getModelDescription(struct soap *soap, const char *tag, struct __ns1__getModelDescription *a, const char *type)
{
	size_t soap_flag_ns2__getModelDescriptionRequest = 1;
	short soap_flag;
	a = (struct __ns1__getModelDescription *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getModelDescription, sizeof(struct __ns1__getModelDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getModelDescription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getModelDescriptionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getModelDescriptionRequest(soap, "ns2:getModelDescriptionRequest", &a->ns2__getModelDescriptionRequest, ""))
				{	soap_flag_ns2__getModelDescriptionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getModelDescription(struct soap *soap, const struct __ns1__getModelDescription *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getModelDescription(soap, tag?tag:"-ns1:getModelDescription", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModelDescription * SOAP_FMAC4 soap_get___ns1__getModelDescription(struct soap *soap, struct __ns1__getModelDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getModelDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getModelDescription * SOAP_FMAC2 soap_instantiate___ns1__getModelDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getModelDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getModelDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getModelDescription);
		if (size)
			*size = sizeof(struct __ns1__getModelDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getModelDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getModelDescription);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getModelDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getModelDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getModelDescription %p -> %p\n", q, p));
	*(struct __ns1__getModelDescription*)p = *(struct __ns1__getModelDescription*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getModelListResponse(struct soap *soap, _ns2__getModelListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getModelListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getModelListResponse(struct soap *soap, const char *tag, int id, _ns2__getModelListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getModelListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getModelListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getModelListResponse(struct soap *soap, const char *tag, _ns2__getModelListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getModelListResponse **)soap_malloc(soap, sizeof(_ns2__getModelListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getModelListResponse *)soap_instantiate__ns2__getModelListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getModelListResponse ** p = (_ns2__getModelListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getModelListResponse, sizeof(_ns2__getModelListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getModelListResponse(struct soap *soap, _ns2__getModelListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getModelListResponse);
	if (soap_out_PointerTo_ns2__getModelListResponse(soap, tag?tag:"ns2:getModelListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__getModelListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getModelListResponse(struct soap *soap, _ns2__getModelListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getModelListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__saveModelDescriptionResponse(struct soap *soap, _ns2__saveModelDescriptionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__saveModelDescriptionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__saveModelDescriptionResponse(struct soap *soap, const char *tag, int id, _ns2__saveModelDescriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__saveModelDescriptionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__saveModelDescriptionResponse(struct soap *soap, const char *tag, _ns2__saveModelDescriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__saveModelDescriptionResponse **)soap_malloc(soap, sizeof(_ns2__saveModelDescriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__saveModelDescriptionResponse *)soap_instantiate__ns2__saveModelDescriptionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__saveModelDescriptionResponse ** p = (_ns2__saveModelDescriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__saveModelDescriptionResponse, sizeof(_ns2__saveModelDescriptionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__saveModelDescriptionResponse(struct soap *soap, _ns2__saveModelDescriptionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__saveModelDescriptionResponse);
	if (soap_out_PointerTo_ns2__saveModelDescriptionResponse(soap, tag?tag:"ns2:saveModelDescriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__saveModelDescriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__saveModelDescriptionResponse(struct soap *soap, _ns2__saveModelDescriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__saveModelDescriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__saveModelDescriptionRequest(struct soap *soap, _ns2__saveModelDescriptionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__saveModelDescriptionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__saveModelDescriptionRequest(struct soap *soap, const char *tag, int id, _ns2__saveModelDescriptionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__saveModelDescriptionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__saveModelDescriptionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns2__saveModelDescriptionRequest(struct soap *soap, const char *tag, _ns2__saveModelDescriptionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__saveModelDescriptionRequest **)soap_malloc(soap, sizeof(_ns2__saveModelDescriptionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__saveModelDescriptionRequest *)soap_instantiate__ns2__saveModelDescriptionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__saveModelDescriptionRequest ** p = (_ns2__saveModelDescriptionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__saveModelDescriptionRequest, sizeof(_ns2__saveModelDescriptionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__saveModelDescriptionRequest(struct soap *soap, _ns2__saveModelDescriptionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__saveModelDescriptionRequest);
	if (soap_out_PointerTo_ns2__saveModelDescriptionRequest(soap, tag?tag:"ns2:saveModelDescriptionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__saveModelDescriptionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns2__saveModelDescriptionRequest(struct soap *soap, _ns2__saveModelDescriptionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__saveModelDescriptionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getModelDescriptionResponse(struct soap *soap, _ns2__getModelDescriptionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getModelDescriptionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getModelDescriptionResponse(struct soap *soap, const char *tag, int id, _ns2__getModelDescriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getModelDescriptionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getModelDescriptionResponse(struct soap *soap, const char *tag, _ns2__getModelDescriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getModelDescriptionResponse **)soap_malloc(soap, sizeof(_ns2__getModelDescriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getModelDescriptionResponse *)soap_instantiate__ns2__getModelDescriptionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getModelDescriptionResponse ** p = (_ns2__getModelDescriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getModelDescriptionResponse, sizeof(_ns2__getModelDescriptionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getModelDescriptionResponse(struct soap *soap, _ns2__getModelDescriptionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getModelDescriptionResponse);
	if (soap_out_PointerTo_ns2__getModelDescriptionResponse(soap, tag?tag:"ns2:getModelDescriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__getModelDescriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getModelDescriptionResponse(struct soap *soap, _ns2__getModelDescriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getModelDescriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getModelDescriptionRequest(struct soap *soap, _ns2__getModelDescriptionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getModelDescriptionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getModelDescriptionRequest(struct soap *soap, const char *tag, int id, _ns2__getModelDescriptionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getModelDescriptionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getModelDescriptionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns2__getModelDescriptionRequest(struct soap *soap, const char *tag, _ns2__getModelDescriptionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getModelDescriptionRequest **)soap_malloc(soap, sizeof(_ns2__getModelDescriptionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getModelDescriptionRequest *)soap_instantiate__ns2__getModelDescriptionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getModelDescriptionRequest ** p = (_ns2__getModelDescriptionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getModelDescriptionRequest, sizeof(_ns2__getModelDescriptionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getModelDescriptionRequest(struct soap *soap, _ns2__getModelDescriptionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getModelDescriptionRequest);
	if (soap_out_PointerTo_ns2__getModelDescriptionRequest(soap, tag?tag:"ns2:getModelDescriptionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__getModelDescriptionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns2__getModelDescriptionRequest(struct soap *soap, _ns2__getModelDescriptionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getModelDescriptionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__model(struct soap *soap, ns2__model *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__model))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__model(struct soap *soap, const char *tag, int id, ns2__model *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__model);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__model ** SOAP_FMAC4 soap_in_PointerTons2__model(struct soap *soap, const char *tag, ns2__model **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__model **)soap_malloc(soap, sizeof(ns2__model *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__model *)soap_instantiate_ns2__model(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__model ** p = (ns2__model **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__model, sizeof(ns2__model), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__model(struct soap *soap, ns2__model *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__model);
	if (soap_out_PointerTons2__model(soap, tag?tag:"ns2:model", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__model ** SOAP_FMAC4 soap_get_PointerTons2__model(struct soap *soap, ns2__model **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__model(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__user(struct soap *soap, ns2__user *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__user))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__user(struct soap *soap, const char *tag, int id, ns2__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__user ** SOAP_FMAC4 soap_in_PointerTons2__user(struct soap *soap, const char *tag, ns2__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__user **)soap_malloc(soap, sizeof(ns2__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__user *)soap_instantiate_ns2__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__user ** p = (ns2__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__user, sizeof(ns2__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__user(struct soap *soap, ns2__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__user);
	if (soap_out_PointerTons2__user(soap, tag?tag:"ns2:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__user ** SOAP_FMAC4 soap_get_PointerTons2__user(struct soap *soap, ns2__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__iteratorContainer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__iteratorContainer(struct soap *soap, const char *tag, int id, ns2__iteratorContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__iteratorContainer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__iteratorContainer ** SOAP_FMAC4 soap_in_PointerTons2__iteratorContainer(struct soap *soap, const char *tag, ns2__iteratorContainer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__iteratorContainer **)soap_malloc(soap, sizeof(ns2__iteratorContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__iteratorContainer *)soap_instantiate_ns2__iteratorContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__iteratorContainer ** p = (ns2__iteratorContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__iteratorContainer, sizeof(ns2__iteratorContainer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__iteratorContainer);
	if (soap_out_PointerTons2__iteratorContainer(soap, tag?tag:"ns2:iteratorContainer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__iteratorContainer ** SOAP_FMAC4 soap_get_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__iteratorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__entity(struct soap *soap, ns2__entity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__entity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__entity(struct soap *soap, const char *tag, int id, ns2__entity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__entity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__entity ** SOAP_FMAC4 soap_in_PointerTons2__entity(struct soap *soap, const char *tag, ns2__entity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__entity **)soap_malloc(soap, sizeof(ns2__entity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__entity *)soap_instantiate_ns2__entity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__entity ** p = (ns2__entity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__entity, sizeof(ns2__entity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__entity(struct soap *soap, ns2__entity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__entity);
	if (soap_out_PointerTons2__entity(soap, tag?tag:"ns2:entity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__entity ** SOAP_FMAC4 soap_get_PointerTons2__entity(struct soap *soap, ns2__entity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__set(struct soap *soap, ns2__set *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__set))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__set(struct soap *soap, const char *tag, int id, ns2__set *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__set);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__set ** SOAP_FMAC4 soap_in_PointerTons2__set(struct soap *soap, const char *tag, ns2__set **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__set **)soap_malloc(soap, sizeof(ns2__set *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__set *)soap_instantiate_ns2__set(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__set ** p = (ns2__set **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__set, sizeof(ns2__set), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__set(struct soap *soap, ns2__set *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__set);
	if (soap_out_PointerTons2__set(soap, tag?tag:"ns2:set", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__set ** SOAP_FMAC4 soap_get_PointerTons2__set(struct soap *soap, ns2__set **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__set(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__modelRev(struct soap *soap, ns2__modelRev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__modelRev))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__modelRev(struct soap *soap, const char *tag, int id, ns2__modelRev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__modelRev);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__modelRev ** SOAP_FMAC4 soap_in_PointerTons2__modelRev(struct soap *soap, const char *tag, ns2__modelRev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__modelRev **)soap_malloc(soap, sizeof(ns2__modelRev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__modelRev *)soap_instantiate_ns2__modelRev(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__modelRev ** p = (ns2__modelRev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__modelRev, sizeof(ns2__modelRev), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__modelRev(struct soap *soap, ns2__modelRev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__modelRev);
	if (soap_out_PointerTons2__modelRev(soap, tag?tag:"ns2:modelRev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__modelRev ** SOAP_FMAC4 soap_get_PointerTons2__modelRev(struct soap *soap, ns2__modelRev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__modelRev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__auditable(struct soap *soap, ns2__auditable *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__auditable))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__auditable(struct soap *soap, const char *tag, int id, ns2__auditable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__auditable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__auditable ** SOAP_FMAC4 soap_in_PointerTons2__auditable(struct soap *soap, const char *tag, ns2__auditable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__auditable **)soap_malloc(soap, sizeof(ns2__auditable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__auditable *)soap_instantiate_ns2__auditable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__auditable ** p = (ns2__auditable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__auditable, sizeof(ns2__auditable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__auditable(struct soap *soap, ns2__auditable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__auditable);
	if (soap_out_PointerTons2__auditable(soap, tag?tag:"ns2:auditable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__auditable ** SOAP_FMAC4 soap_get_PointerTons2__auditable(struct soap *soap, ns2__auditable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__auditable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__model(struct soap *soap, std::vector<ns2__model * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__model(struct soap *soap, const std::vector<ns2__model * >*a)
{
	for (std::vector<ns2__model * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__model(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__model(struct soap *soap, const char *tag, int id, const std::vector<ns2__model * >*a, const char *type)
{
	for (std::vector<ns2__model * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__model(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__model * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__model(struct soap *soap, const char *tag, std::vector<ns2__model * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__model(soap, -1)))
		return NULL;
	ns2__model *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__model, SOAP_TYPE_std__vectorTemplateOfPointerTons2__model, sizeof(ns2__model), 1))
				break;
			if (!soap_in_PointerTons2__model(soap, tag, NULL, "ns2:model"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__model(soap, tag, &n, "ns2:model"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__model * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__model(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__model(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__model, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__model * >);
		if (size)
			*size = sizeof(std::vector<ns2__model * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__model * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__model * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__model * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__model(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__model * > %p -> %p\n", q, p));
	*(std::vector<ns2__model * >*)p = *(std::vector<ns2__model * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, std::vector<ns2__entity * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, const std::vector<ns2__entity * >*a)
{
	for (std::vector<ns2__entity * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__entity(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, const char *tag, int id, const std::vector<ns2__entity * >*a, const char *type)
{
	for (std::vector<ns2__entity * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__entity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__entity * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, const char *tag, std::vector<ns2__entity * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__entity(soap, -1)))
		return NULL;
	ns2__entity *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__entity, SOAP_TYPE_std__vectorTemplateOfPointerTons2__entity, sizeof(ns2__entity), 1))
				break;
			if (!soap_in_PointerTons2__entity(soap, tag, NULL, "ns2:entity"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__entity(soap, tag, &n, "ns2:entity"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__entity * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__entity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__entity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__entity * >);
		if (size)
			*size = sizeof(std::vector<ns2__entity * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__entity * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__entity * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__entity * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__entity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__entity * > %p -> %p\n", q, p));
	*(std::vector<ns2__entity * >*)p = *(std::vector<ns2__entity * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__set(struct soap *soap, std::vector<ns2__set * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__set(struct soap *soap, const std::vector<ns2__set * >*a)
{
	for (std::vector<ns2__set * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__set(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__set(struct soap *soap, const char *tag, int id, const std::vector<ns2__set * >*a, const char *type)
{
	for (std::vector<ns2__set * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__set(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__set * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__set(struct soap *soap, const char *tag, std::vector<ns2__set * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__set(soap, -1)))
		return NULL;
	ns2__set *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__set, SOAP_TYPE_std__vectorTemplateOfPointerTons2__set, sizeof(ns2__set), 1))
				break;
			if (!soap_in_PointerTons2__set(soap, tag, NULL, "ns2:set"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__set(soap, tag, &n, "ns2:set"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__set * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__set(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__set(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__set, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__set * >);
		if (size)
			*size = sizeof(std::vector<ns2__set * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__set * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__set * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__set * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__set(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__set * > %p -> %p\n", q, p));
	*(std::vector<ns2__set * >*)p = *(std::vector<ns2__set * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, std::vector<ns2__modelRev * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, const std::vector<ns2__modelRev * >*a)
{
	for (std::vector<ns2__modelRev * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__modelRev(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, const char *tag, int id, const std::vector<ns2__modelRev * >*a, const char *type)
{
	for (std::vector<ns2__modelRev * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__modelRev(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__modelRev * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, const char *tag, std::vector<ns2__modelRev * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__modelRev(soap, -1)))
		return NULL;
	ns2__modelRev *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__modelRev, SOAP_TYPE_std__vectorTemplateOfPointerTons2__modelRev, sizeof(ns2__modelRev), 1))
				break;
			if (!soap_in_PointerTons2__modelRev(soap, tag, NULL, "ns2:modelRev"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__modelRev(soap, tag, &n, "ns2:modelRev"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__modelRev * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__modelRev(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__modelRev, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__modelRev * >);
		if (size)
			*size = sizeof(std::vector<ns2__modelRev * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__modelRev * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__modelRev * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__modelRev * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__modelRev(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__modelRev * > %p -> %p\n", q, p));
	*(std::vector<ns2__modelRev * >*)p = *(std::vector<ns2__modelRev * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
